
// fileopentestDlg.cpp : 구현 파일
//

#include "stdafx.h"
#include "fileopentest.h"
#include "fileopentestDlg.h"
#include "afxdialogex.h"
#include "windows.h"
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


CfileopentestDlg *pThis = NULL;


// LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
// HINSTANCE g_hInst;
// LPCTSTR lpszClass = TEXT("First");  //윈도우 이름 및 타이틀바에 등록할 문자열
// HWND g_hWnd; 


DWORD CALLBACK CopyProgressRoutine(
	LARGE_INTEGER TotalFileSize,
	LARGE_INTEGER TotalBytesTransferred,
	LARGE_INTEGER StreamSize,
	LARGE_INTEGER StreamBytesTransferred,
	DWORD dwStreamNumber,
	DWORD dwCallbackReason,
	HANDLE hSourceFile,
	HANDLE hDestinationFile,
	LPVOID lpData);



// 응용 프로그램 정보에 사용되는 CAboutDlg 대화 상자입니다.

class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

// 대화 상자 데이터입니다.
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_ABOUTBOX };
#endif

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 지원입니다.

// 구현입니다.
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}
 
BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()


// CfileopentestDlg 대화 상자



CfileopentestDlg::CfileopentestDlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(IDD_FILEOPENTEST_DIALOG, pParent)
{
	pThis = this;
	strUserFolderName = L"";
	strChoosenType = L"";
	Preset_Array();	//190128 YWCho 
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CfileopentestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_EDIT1, m_ctrl_Edit1);
	DDX_Control(pDX, IDC_EDIT2, m_ctrl_Edit2);
	DDX_Control(pDX, IDC_PROGRESS1, m_progress);
	DDX_Control(pDX, IDC_CHECK1_1, m_check[0][0]);
	DDX_Control(pDX, IDC_CHECK1_2, m_check[0][1]);
	DDX_Control(pDX, IDC_CHECK1_3, m_check[0][2]);
	DDX_Control(pDX, IDC_CHECK1_4, m_check[0][3]);

	DDX_Control(pDX, IDC_CHECK2_1, m_check[1][0]);
	DDX_Control(pDX, IDC_CHECK2_2, m_check[1][1]);
	DDX_Control(pDX, IDC_CHECK2_3, m_check[1][2]);
	DDX_Control(pDX, IDC_CHECK2_4, m_check[1][3]);

	DDX_Control(pDX, IDC_CHECK3_1, m_check[2][0]);
	DDX_Control(pDX, IDC_CHECK3_2, m_check[2][1]);
	DDX_Control(pDX, IDC_CHECK3_3, m_check[2][2]);

	DDX_Control(pDX, IDC_CHECK4_1, m_check[3][0]);
	DDX_Control(pDX, IDC_CHECK4_2, m_check[3][1]);
	DDX_Control(pDX, IDC_CHECK4_3, m_check[3][2]);
	DDX_Control(pDX, IDC_CHECK4_4, m_check[3][3]);

	DDX_Control(pDX, IDC_CHECK5_1, m_check[4][0]);
	DDX_Control(pDX, IDC_CHECK5_2, m_check[4][1]);
	DDX_Control(pDX, IDC_CHECK5_3, m_check[4][2]);

	DDX_Control(pDX, IDC_CHECK6_1, m_check[5][0]);
	DDX_Control(pDX, IDC_CHECK_ALL, m_check_all);
	DDX_Control(pDX, IDC_CHECK_USER, m_check_user);
	DDX_Control(pDX, IDC_EDIT_USER, m_ctrl_user);
	DDX_Control(pDX, IDC_TXT_PROGRESS, m_txtctrl_pgbar);
	DDX_Control(pDX, IDC_BTN_WORK, m_btn_work);
}

BEGIN_MESSAGE_MAP(CfileopentestDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BTN_WORK, &CfileopentestDlg::OnBnClickedBtnWork)
	ON_BN_CLICKED(IDC_BUTTON1, &CfileopentestDlg::OnBnClickedButton1)
	ON_BN_CLICKED(IDC_BUTTON2, &CfileopentestDlg::OnBnClickedButton2)
	ON_BN_CLICKED(IDC_CHECK_ALL, &CfileopentestDlg::OnBnClickedCheckAll)
	ON_BN_CLICKED(IDOK, &CfileopentestDlg::OnBnClickedOk)
	ON_BN_CLICKED(IDCANCEL, &CfileopentestDlg::OnBnClickedCancel)
	ON_BN_CLICKED(IDC_BTN_COPYCANCEL, &CfileopentestDlg::OnBnClickedBtnCopycancel)
END_MESSAGE_MAP()


// CfileopentestDlg 메시지 처리기

BOOL CfileopentestDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// 시스템 메뉴에 "정보..." 메뉴 항목을 추가합니다.

	// IDM_ABOUTBOX는 시스템 명령 범위에 있어야 합니다.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// 이 대화 상자의 아이콘을 설정합니다.  응용 프로그램의 주 창이 대화 상자가 아닐 경우에는
	//  프레임워크가 이 작업을 자동으로 수행합니다.
	SetIcon(m_hIcon, TRUE);			// 큰 아이콘을 설정합니다.
	SetIcon(m_hIcon, FALSE);		// 작은 아이콘을 설정합니다.

	// TODO: 여기에 추가 초기화 작업을 추가합니다.
	//m_progress.SetRange(0, 100);

	return TRUE;  // 포커스를 컨트롤에 설정하지 않으면 TRUE를 반환합니다.
}

void CfileopentestDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// 대화 상자에 최소화 단추를 추가할 경우 아이콘을 그리려면
//  아래 코드가 필요합니다.  문서/뷰 모델을 사용하는 MFC 응용 프로그램의 경우에는
//  프레임워크에서 이 작업을 자동으로 수행합니다.

void CfileopentestDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 그리기를 위한 디바이스 컨텍스트입니다.

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 클라이언트 사각형에서 아이콘을 가운데에 맞춥니다.
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 아이콘을 그립니다.
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

// 사용자가 최소화된 창을 끄는 동안에 커서가 표시되도록 시스템에서
//  이 함수를 호출합니다.
HCURSOR CfileopentestDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

void CfileopentestDlg::Preset_Array()
{
	//190128 YWCho strFileType배열 초기값 저장 
	strFileType[eTYPE_FUJIFILM] = TYPE_FUJIFILM;
	strFileType[eTYPE_OLYMPUS] = TYPE_OLYMPUS;
	strFileType[eTYPE_EPSON] = TYPE_EPSON;
	strFileType[eTYPE_IMACON] = TYPE_IMACON;
	strFileType[eTYPE_CANON1] = TYPE_CANON1;
	strFileType[eTYPE_CANON2] = TYPE_CANON2;
	strFileType[eTYPE_CANON3] = TYPE_CANON3;
	strFileType[eTYPE_ADOBE] = TYPE_ADOBE;
	strFileType[eTYPE_MAMIYA1] = TYPE_MAMIYA1;
	strFileType[eTYPE_MAMIYA2] = TYPE_MAMIYA2;
	strFileType[eTYPE_LOGITECH] = TYPE_LOGITECH;
	strFileType[eTYPE_SAMSUNG] = TYPE_SAMSUNG;
	strFileType[eTYPE_PENTAX1] = TYPE_PENTAX1;
	strFileType[eTYPE_PENTAX2] = TYPE_PENTAX2;
	strFileType[eTYPE_PANASONIC] = TYPE_PANASONIC;
	strFileType[eTYPE_CASIO] = TYPE_CASIO;
	strFileType[eTYPE_KODAK1] = TYPE_KODAK1;
	strFileType[eTYPE_KODAK2] = TYPE_KODAK2;
	strFileType[eTYPE_KODAK3] = TYPE_KODAK3;
	strFileType[eTYPE_KODAK4] = TYPE_KODAK4;
	strFileType[eTYPE_KODAK5] = TYPE_KODAK5;
	strFileType[eTYPE_KODAK6] = TYPE_KODAK6;
	strFileType[eTYPE_SONY1] = TYPE_SONY1;
	strFileType[eTYPE_SONY2] = TYPE_SONY2;
	strFileType[eTYPE_SONY3] = TYPE_SONY3;
	strFileType[eTYPE_PHASEONE1] = TYPE_PHASEONE1;
	strFileType[eTYPE_PHASEONE2] = TYPE_PHASEONE2;
	strFileType[eTYPE_PHASEONE3] = TYPE_PHASEONE3;
	strFileType[eTYPE_MINOLTA] = TYPE_MINOLTA;
	strFileType[eTYPE_SIGMA] = TYPE_SIGMA;
	strFileType[eTYPE_RED] = TYPE_RED;
	strFileType[eTYPE_NICON1] = TYPE_NICON1;
	strFileType[eTYPE_NICON2] = TYPE_NICON2;
}

void CfileopentestDlg::CheckBoxDataSetting()
{
	CString strtmp;
	int nID = 0;
	strChoosenType = L"";
	for (int i = 0; i < 6; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			if (m_check[i][j].m_hWnd != NULL)	//존재하는 버튼일 경우!
			{
				bool bVal = m_check[i][j].GetCheck();	//버튼 체크 여부 판단 변수 
				if (bVal == true)
				{
					nID = m_check[i][j].GetDlgCtrlID();
					switch (nID)
					{	// ","개수로 찾아야 할 확장자명 개수를 알 수 있음.
					case IDC_CHECK1_1:
						strChoosenType += strFileType[eTYPE_SONY1] + L",@";
						strChoosenType += strFileType[eTYPE_SONY2] + L",@";
						strChoosenType += strFileType[eTYPE_SONY3] + L",@";
						break;
					case IDC_CHECK1_2:
						strChoosenType += strFileType[eTYPE_CANON1] + L",@";
						strChoosenType += strFileType[eTYPE_CANON2] + L",@";
						strChoosenType += strFileType[eTYPE_CANON3] + L",@";
						break;
					case IDC_CHECK1_3:
						strChoosenType += strFileType[eTYPE_NICON1] + L",@";
						strChoosenType += strFileType[eTYPE_NICON2] + L",@";
						break;
					case IDC_CHECK1_4:
						strChoosenType += strFileType[eTYPE_OLYMPUS] + L",@";
						break;

					case IDC_CHECK2_1:
						strChoosenType += strFileType[eTYPE_PANASONIC] + L",@";
						break;
					case IDC_CHECK2_2:
						strChoosenType += strFileType[eTYPE_SAMSUNG] + L",@";
						break;
					case IDC_CHECK2_3:
						strChoosenType += strFileType[eTYPE_PENTAX1] + L",@";
						strChoosenType += strFileType[eTYPE_PENTAX2] + L",@";
						break;
					case IDC_CHECK2_4:
						strChoosenType += strFileType[eTYPE_EPSON] + L",@";
						break;

					case IDC_CHECK3_1:
						strChoosenType += strFileType[eTYPE_MINOLTA] + L",@";
						break;
					case IDC_CHECK3_2:
						strChoosenType += strFileType[eTYPE_FUJIFILM] + L",@";
						break;
					case IDC_CHECK3_3:
						strChoosenType += strFileType[eTYPE_KODAK1] + L",@";
						strChoosenType += strFileType[eTYPE_KODAK2] + L",@";
						strChoosenType += strFileType[eTYPE_KODAK3] + L",@";
						strChoosenType += strFileType[eTYPE_KODAK4] + L",@";
						strChoosenType += strFileType[eTYPE_KODAK5] + L",@";
						strChoosenType += strFileType[eTYPE_KODAK6] + L",@";
						break;

					case IDC_CHECK4_1:
						strChoosenType += strFileType[eTYPE_ADOBE] + L",@";
						break;
					case IDC_CHECK4_2:
						strChoosenType += strFileType[eTYPE_LOGITECH] + L",@";
						break;
					case IDC_CHECK4_3:
						strChoosenType += strFileType[eTYPE_SIGMA] + L",@";
						break;
					case IDC_CHECK4_4:
						strChoosenType += strFileType[eTYPE_CASIO] + L",@";
						break;

					case IDC_CHECK5_1:
						strChoosenType += strFileType[eTYPE_MAMIYA1] + L",@";
						strChoosenType += strFileType[eTYPE_MAMIYA2] + L",@";
						break;
					case IDC_CHECK5_2:
						strChoosenType += strFileType[eTYPE_RED] + L",@";
						break;
					case IDC_CHECK5_3:
						strChoosenType += strFileType[eTYPE_IMACON] + L",@";
						break;

					case IDC_CHECK6_1:
						strChoosenType += strFileType[eTYPE_PHASEONE1] + L",@";
						strChoosenType += strFileType[eTYPE_PHASEONE2] + L",@";
						strChoosenType += strFileType[eTYPE_PHASEONE3] + L",@";
						break;

					default:
						break;
					}
				}
			}
		}
	}

	bool bVal = m_check_user.GetCheck();									//버튼 체크 여부 판단 변수 
	if (bVal == true)
	{
		GetDlgItemText(IDC_EDIT_USER, strtmp);
		strtmp.Remove(L' ');
		if (strtmp == L"")
			return;
		else
			strChoosenType += strtmp + L",@";
	}
	else
		return;


}

bool CfileopentestDlg::CheckTypeSelected()
{
	for (int i = 0; i < 6; i++) {
		for (int j = 0; j < 4; j++) {
			if (m_check[i][j].m_hWnd != NULL)								//존재하는 버튼일 경우!
			{
				bool bVal = m_check[i][j].GetCheck();						//버튼 체크 여부 판단 변수 
				if (bVal == true) {
					return true;
				}
			}
		}
	}

	AfxMessageBox(L"확장자가 선택되지 않았습니다.");
	return false;
}

bool CfileopentestDlg::CheckPathSelected()
{
	if (strFilePath_A == "" || strFilePath_B == "")							//경로 미 지정시 종료
	{
		AfxMessageBox(L"경로가 지정되지 않았습니다.");
		return false;
	}

	return true;
}

void CfileopentestDlg::OnBnClickedButton1()									//선택된 파일
{
	CFolderPickerDialog dlg(NULL, 0, NULL, 0);

	if (IDOK == dlg.DoModal()) {

		strFilePath_A = dlg.GetPathName();
		strFolderName_A = dlg.GetFileName();
		m_ctrl_Edit1.SetWindowTextW(strFilePath_A);	
	}

}

void CfileopentestDlg::OnBnClickedButton2()									//원본 파일
{
	CFolderPickerDialog dlg(NULL, 0, NULL, 0);

	if (IDOK == dlg.DoModal()) {

		strFilePath_B = dlg.GetPathName();
		m_ctrl_Edit2.SetWindowTextW(strFilePath_B);							//폴더 경로
	}
}

void CfileopentestDlg::OnBnClickedBtnWork()
{
	if (!CheckTypeSelected())												//확장자 미체크시 종료
		return;

	if (!CheckPathSelected())												//경로 미 지정시 종료 
		return;

	vecExtension.clear();
	vecFileName_jpg.clear();
	vecFileName_raw.clear();
	vecFileName_jpg_except.clear();


	m_progress.SetPos(0);													//190318 PG Bar 초기화 

	CFileFind finder;
	CString default_type = L"";

	int nFileCnt(0);
	int nPrBarCnt(0);
	int nNoneCnt(0);
	bCancel = FALSE;

	BOOL bIsFile = finder.FindFile(strFilePath_A + L"\\*.*", 0);			//A폴더 경로에서 *.* 파일을 발견하면 TRUE 
	if (bIsFile == 0)														//A폴더에 내용 없으면 return 						
	{
		AfxMessageBox(L"선택된 폴더에 파일이 존재하지 않습니다.");
		return;
	}

	//>>>>>>>>>>>>>>>>>>>>>>>>> find jpg files //>>>>>>>>>>>>>>>>>>>>>>>>>//>>>>>>>>>>>>>>>>>>>>>>>>>
	while (bIsFile != 0)
	{
		bIsFile = finder.FindNextFile();
		CString str = finder.GetFileName();

		int nFileLength = str.GetLength();									//파일명 길이 구하기
		int nFindPos = str.Find(L".");										//파일명에서 "."찾기
		if (nFileCnt >= 2) {
			if (nFindPos > 0)												// 두번째까지 이상한 값이 들어와서 이렇게 사용함. //만약 찾으면
			{
				vecFileName_jpg.push_back(str);
				CString strOnlyName = str.Left(nFindPos);
				strFileName[nFileCnt - 2] = strOnlyName;					//strFileName배열에 파일 이름 저장 
				CString ss = str.Right(nFileLength - nFindPos);
				if (ss.GetLength() > 2 && default_type == L"")
					default_type = ss;
			}
			else
			{
				nFileCnt--;													//파일 형식이 name.***가 아니기 때문에 nFileCnt에 제외시킴 
			}
		}
		nFileCnt++;	
	}
	nFileCnt -= 2;															//마지막에 2를 빼주기~
	sort(vecFileName_jpg.begin(), vecFileName_jpg.end());

	//>>>>>>>>>>>>>>>>>>>>>>>>> find raw files  //>>>>>>>>>>>>>>>>>>>>>>>>>//>>>>>>>>>>>>>>>>>>>>>>>>
	bIsFile = finder.FindFile(strFilePath_B + L"\\*.*", 0);			//A폴더 경로에서 *.* 파일을 발견하면 TRUE 
	if (bIsFile == 0)														//A폴더에 내용 없으면 return 						
	{
		AfxMessageBox(L"원본 폴더에 파일이 존재하지 않습니다.");
		return;
	}

	int tmpcnt=0;
	while (bIsFile != 0)
	{
		bIsFile = finder.FindNextFile();
		CString str = finder.GetFileName();

		int nFileLength = str.GetLength();									//파일명 길이 구하기
		int nFindPos = str.Find(L".");										//파일명에서 "."찾기
		if (tmpcnt >= 2) {
			if (nFindPos > 0)												// 두번째까지 이상한 값이 들어와서 이렇게 사용함. //만약 찾으면
			{
				vecFileName_raw.push_back(str);
			}
			else
			{
				tmpcnt--;													//파일 형식이 name.***가 아니기 때문에 nFileCnt에 제외시킴 
			}
		}
		tmpcnt++;
	}
	tmpcnt -= 2;															//마지막에 2를 빼주기~
	sort(vecFileName_raw.begin(), vecFileName_raw.end());




	//>>>>>>>>>>>>>>>>>>>>>>>>> find raw files  //>>>>>>>>>>>>>>>>>>>>>>>>>//>>>>>>>>>>>>>>>>>>>>>>>>>
	m_progress.SetRange(0, nFileCnt);										//progressbar control
	CheckBoxDataSetting();
	CString strUserPath = (L"%s", strFilePath_A + L"\\" + strFolderName_A + L"_Original");	//190126
	int nTypeCnt = strChoosenType.Remove(L'@');
	strChoosenType.Remove(L'.');

	CString TEMPstrChoosenType = strChoosenType;						//확장명 복사 
	for (int j = 0; j < nTypeCnt; j++)
	{
		int n = TEMPstrChoosenType.Find(L',');							// ,(comma)의 위치값을 나타내는 변수.
		CString str = TEMPstrChoosenType.Left(n);						// ,전까지의 문자열을 str 변수에 저장.
		vecExtension.push_back(str);
		TEMPstrChoosenType.TrimLeft(str);									//첫번째 확장자 삭제하고,
		TEMPstrChoosenType.TrimLeft(',');								//컴마까지 삭제완료 한다.
	}


	//220525 YWCho : 중복 jpg 파일 제거 
	vector<CString> vec2Erase;
	for (int i = 0; i < vecFileName_jpg.size(); i++)
	{
		vector<CString> vec2Erase;
		CString full_name_jpg = vecFileName_jpg[i];
		CString name_jpg = vecFileName_jpg[i].Left(vecFileName_jpg[i].Find(L"."));

		bool bExistFlag = false;
		for (int j = 0; j < vecFileName_raw.size(); j++)
		{
			CString full_name_raw = vecFileName_raw[j];
			CString name_raw = vecFileName_raw[j].Left(vecFileName_raw[j].Find(L"."));
			CString extension_name_raw = vecFileName_raw[j].Right(vecFileName_raw[j].GetLength() - vecFileName_raw[j].Find(L".") - 1);
			//먼저 같은 이름을 가진 파일에 한해서
			if (name_jpg == name_raw)
			{
				bExistFlag = true;

				//1. 같은 이름을 가진 파일 제거
				if (full_name_jpg == full_name_raw)
				{
					vec2Erase.push_back(vecFileName_raw[j]);
					//vecFileName_raw.erase(vecFileName_raw.begin() + j);
					break;
				}

				//2. 선택하지 않은 확장자 제거
				bool bEraseFlag = true;
				for (int k = 0; k < vecExtension.size(); k++)
				{
					if (vecExtension[k].MakeLower() == extension_name_raw.MakeLower())
					{
						bEraseFlag = false;
						break;
					}
				}

				if (bEraseFlag == true)
				{
					vec2Erase.push_back(vecFileName_raw[j]);
				}
			}
		}

		for (int l=0;l<vec2Erase.size();l++)
		{
			vecFileName_raw.erase(find(vecFileName_raw.begin(), vecFileName_raw.end(), vec2Erase[l]));
		}

		if (bExistFlag == false)
		{
			vecFileName_jpg_except.push_back(vecFileName_jpg[i]);
			nNoneCnt++;
		}
	}
	
	//>> 220502 YWCho : 파일 복사 
	for (int i = 0; i < vecFileName_raw.size(); i++)
	{
		CString strPath = strFilePath_B + L"\\" + vecFileName_raw[i];
		CString strNewPath = strUserPath + L"\\" + vecFileName_raw[i];		//새로운 폴더에 붙여넣기 하기위한 경로

		if (finder.FindFile(strPath) == TRUE)							//파일을 발견하면 
		{
			DWORD dwRet = GetFileAttributes(strUserPath);				//파일 속성 얻기.		
			if (dwRet != FILE_ATTRIBUTE_DIRECTORY)						// 폴더가 존재하지 않는 경우.
				CreateDirectory(strUserPath, NULL);						// 폴더 생성 

			CopyFileEx(strPath, strNewPath, CopyProgressRoutine, NULL, &bCancel, COPY_FILE_FAIL_IF_EXISTS);

			nPrBarCnt++;		//progress bar control
		}
		m_progress.SetPos(nPrBarCnt);									//progressbar control
	}



	//>>	190214 YWCho 확장자 선택 알고리즘 추가

// 	for (int i = 0; i < nFileCnt; i++)										//선택한 폴더의 사진 수만큼 반복
// 	{
// 		CString TEMPstrChoosenType = strChoosenType;						//확장명 복사 
// 		int TEMPPrBarCnt = nPrBarCnt;
// 		for (int j = 0; j < nTypeCnt; j++)
// 		{
// 			int n = TEMPstrChoosenType.Find(L',');							// ,(comma)의 위치값을 나타내는 변수.
// 			CString str = TEMPstrChoosenType.Left(n);						// ,전까지의 문자열을 str 변수에 저장.
// 			//찾는 알고리즘 피룡 
// 			CString strPath = strFilePath_B + L"\\" + strFileName[i] + str;	//원본에서 파일 찾기위한 경로
// 			CString strNewPath = strUserPath + strFileName[i] + str;		//새로운 폴더에 붙여넣기 하기위한 경로
// 
// 			if (finder.FindFile(strPath) == TRUE)							//파일을 발견하면 
// 			{
// 				DWORD dwRet = GetFileAttributes(strUserPath);				//파일 속성 얻기.		
// 				if (dwRet != FILE_ATTRIBUTE_DIRECTORY)						// 폴더가 존재하지 않는 경우.
// 					CreateDirectory(strUserPath, NULL);						// 폴더 생성 
// 
// 				CopyFileEx(strPath, strNewPath, CopyProgressRoutine, NULL, &bCancel, COPY_FILE_FAIL_IF_EXISTS);
// 				//CopyFile(strPath, strNewPath,false);
// 				//MoveFileWithProgressW(strPath, strNewPath, NULL, NULL, 0);
// 
// 				nPrBarCnt++;												//progress bar control
// 			}
// 
// 			m_progress.SetPos(nPrBarCnt);									//progressbar control
// 
// 																			//첫번째 확장자에 관한 비교가 끝나면 
// 			TEMPstrChoosenType.TrimLeft(str);								//첫번째 확장자 삭제하고,
// 			TEMPstrChoosenType.TrimLeft(',');								//컴마까지 삭제완료 한다.
// 		}
// 
// 		if (TEMPPrBarCnt == nPrBarCnt)										//한 파일에 대한 여러 확장자를 다 검색해도 파일을 발견하지 못하면 
// 		{
// 			strFileNone[nNoneCnt] = strFileName[i];
// 			nNoneCnt++;
// 		}
// 	}
	//<<

	CString strTemp;
	strTemp.Format(L"%d개의 선택된 사진 중 %d개의 원본사진 복사 완료", nFileCnt, nPrBarCnt);
	AfxMessageBox(strTemp);
	if (nNoneCnt != 0) {
		strTemp.Format(L"원본 파일이 없는 파일도 복사하시겠습니까?(%d 개)", nNoneCnt);
		if (AfxMessageBox(strTemp, MB_YESNO) == IDYES)
		{
			int nConfirm = 0;

			for (int i = 0; i < vecFileName_jpg_except.size(); i++)
			{
				CString strPath = strFilePath_A + L"\\" + vecFileName_jpg_except[i];
				CString strNewPath = strUserPath + L"\\" + vecFileName_jpg_except[i];		//새로운 폴더에 붙여넣기 하기위한 경로

				if (finder.FindFile(strPath) == TRUE)							//파일을 발견하면 
				{
					DWORD dwRet = GetFileAttributes(strUserPath);				//파일 속성 얻기.		
					if (dwRet != FILE_ATTRIBUTE_DIRECTORY)						// 폴더가 존재하지 않는 경우.
						CreateDirectory(strUserPath, NULL);						// 폴더 생성 

					CopyFileEx(strPath, strNewPath, CopyProgressRoutine, NULL, &bCancel, COPY_FILE_FAIL_IF_EXISTS);

					nConfirm++;		//progress bar control
				}
				m_progress.SetPos(nPrBarCnt + nConfirm);									//progressbar control
			}
			strTemp.Format(L"%d개의 사진 복사 완료", nConfirm);
			AfxMessageBox(strTemp);
		}
	}

// 	for (int i = nPrBarCnt+1 ; i <= nFileCnt; i++)						//상태바 마저 체우기 190214
// 		m_progress.SetPos(i);


	ShellExecute(NULL, _T("open"), strUserPath, NULL, NULL, SW_SHOW);
}

void CfileopentestDlg::OnBnClickedCheckAll()
{
	bool bVal = m_check_all.GetCheck();									//버튼 체크 여부 판단 변수 

	for (int i = 0; i < 6; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			if (m_check[i][j].m_hWnd != NULL)
			{
				m_check[i][j].SetCheck(bVal);							//체크 여부에 따라 체크
			}
		}
	}
}

DWORD CALLBACK CopyProgressRoutine(
	LARGE_INTEGER TotalFileSize,
	LARGE_INTEGER TotalBytesTransferred,
	LARGE_INTEGER StreamSize,
	LARGE_INTEGER StreamBytesTransferred,
	DWORD dwStreamNumber,
	DWORD dwCallbackReason,
	HANDLE hSourceFile,
	HANDLE hDestinationFile,
	LPVOID lpData)
{
	CString str;
	str.Format(L"%d   /   %d", TotalFileSize.LowPart, TotalBytesTransferred.LowPart);
	SetWindowTextW(pThis->m_txtctrl_pgbar, str);

	return PROGRESS_CONTINUE;
}

void CfileopentestDlg::OnBnClickedOk()
{
	CDialog::OnOK();
}


void CfileopentestDlg::OnBnClickedCancel()
{
	CDialogEx::OnCancel();
}


void CfileopentestDlg::OnBnClickedBtnCopycancel()
{

}
