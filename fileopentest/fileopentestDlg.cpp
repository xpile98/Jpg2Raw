
// fileopentestDlg.cpp : 구현 파일
//

#include "stdafx.h"
#include "fileopentest.h"
#include "fileopentestDlg.h"
#include "afxdialogex.h"
#include "windows.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


CfileopentestDlg *pThis = NULL;


// LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
// HINSTANCE g_hInst;
// LPCTSTR lpszClass = TEXT("First");  //윈도우 이름 및 타이틀바에 등록할 문자열
// HWND g_hWnd; 


DWORD CALLBACK CopyProgressRoutine(
	LARGE_INTEGER TotalFileSize,
	LARGE_INTEGER TotalBytesTransferred,
	LARGE_INTEGER StreamSize,
	LARGE_INTEGER StreamBytesTransferred,
	DWORD dwStreamNumber,
	DWORD dwCallbackReason,
	HANDLE hSourceFile,
	HANDLE hDestinationFile,
	LPVOID lpData);



// 응용 프로그램 정보에 사용되는 CAboutDlg 대화 상자입니다.

class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

// 대화 상자 데이터입니다.
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_ABOUTBOX };
#endif

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 지원입니다.

// 구현입니다.
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}
 
BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()


// CfileopentestDlg 대화 상자



CfileopentestDlg::CfileopentestDlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(IDD_FILEOPENTEST_DIALOG, pParent)
{
	pThis = this;
	strUserFolderName = L"";
	strChoosenType = L"";
	Preset_Array();	//190128 YWCho 
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CfileopentestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_EDIT1, m_ctrl_Edit1);
	DDX_Control(pDX, IDC_EDIT2, m_ctrl_Edit2);
	DDX_Control(pDX, IDC_PROGRESS1, m_progress);
	DDX_Control(pDX, IDC_CHECK1_1, m_check[0][0]);
	DDX_Control(pDX, IDC_CHECK1_2, m_check[0][1]);
	DDX_Control(pDX, IDC_CHECK1_3, m_check[0][2]);
	DDX_Control(pDX, IDC_CHECK1_4, m_check[0][3]);

	DDX_Control(pDX, IDC_CHECK2_1, m_check[1][0]);
	DDX_Control(pDX, IDC_CHECK2_2, m_check[1][1]);
	DDX_Control(pDX, IDC_CHECK2_3, m_check[1][2]);
	DDX_Control(pDX, IDC_CHECK2_4, m_check[1][3]);

	DDX_Control(pDX, IDC_CHECK3_1, m_check[2][0]);
	DDX_Control(pDX, IDC_CHECK3_2, m_check[2][1]);
	DDX_Control(pDX, IDC_CHECK3_3, m_check[2][2]);

	DDX_Control(pDX, IDC_CHECK4_1, m_check[3][0]);
	DDX_Control(pDX, IDC_CHECK4_2, m_check[3][1]);
	DDX_Control(pDX, IDC_CHECK4_3, m_check[3][2]);
	DDX_Control(pDX, IDC_CHECK4_4, m_check[3][3]);

	DDX_Control(pDX, IDC_CHECK5_1, m_check[4][0]);
	DDX_Control(pDX, IDC_CHECK5_2, m_check[4][1]);
	DDX_Control(pDX, IDC_CHECK5_3, m_check[4][2]);

	DDX_Control(pDX, IDC_CHECK6_1, m_check[5][0]);
	DDX_Control(pDX, IDC_CHECK_ALL, m_check_all);
	DDX_Control(pDX, IDC_CHECK_USER, m_check_user);
	DDX_Control(pDX, IDC_EDIT_USER, m_ctrl_user);
	DDX_Control(pDX, IDC_TXT_PROGRESS, m_txtctrl_pgbar);
	DDX_Control(pDX, IDC_BTN_WORK, m_btn_work);
}

BEGIN_MESSAGE_MAP(CfileopentestDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BTN_WORK, &CfileopentestDlg::OnBnClickedBtnWork)
	ON_BN_CLICKED(IDC_BUTTON1, &CfileopentestDlg::OnBnClickedButton1)
	ON_BN_CLICKED(IDC_BUTTON2, &CfileopentestDlg::OnBnClickedButton2)
	ON_BN_CLICKED(IDC_CHECK_ALL, &CfileopentestDlg::OnBnClickedCheckAll)
	ON_BN_CLICKED(IDOK, &CfileopentestDlg::OnBnClickedOk)
	ON_BN_CLICKED(IDCANCEL, &CfileopentestDlg::OnBnClickedCancel)
	ON_BN_CLICKED(IDC_BTN_COPYCANCEL, &CfileopentestDlg::OnBnClickedBtnCopycancel)
END_MESSAGE_MAP()


// CfileopentestDlg 메시지 처리기

BOOL CfileopentestDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// 시스템 메뉴에 "정보..." 메뉴 항목을 추가합니다.

	// IDM_ABOUTBOX는 시스템 명령 범위에 있어야 합니다.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// 이 대화 상자의 아이콘을 설정합니다.  응용 프로그램의 주 창이 대화 상자가 아닐 경우에는
	//  프레임워크가 이 작업을 자동으로 수행합니다.
	SetIcon(m_hIcon, TRUE);			// 큰 아이콘을 설정합니다.
	SetIcon(m_hIcon, FALSE);		// 작은 아이콘을 설정합니다.

	// TODO: 여기에 추가 초기화 작업을 추가합니다.
	//m_progress.SetRange(0, 100);

	return TRUE;  // 포커스를 컨트롤에 설정하지 않으면 TRUE를 반환합니다.
}

void CfileopentestDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// 대화 상자에 최소화 단추를 추가할 경우 아이콘을 그리려면
//  아래 코드가 필요합니다.  문서/뷰 모델을 사용하는 MFC 응용 프로그램의 경우에는
//  프레임워크에서 이 작업을 자동으로 수행합니다.

void CfileopentestDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 그리기를 위한 디바이스 컨텍스트입니다.

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 클라이언트 사각형에서 아이콘을 가운데에 맞춥니다.
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 아이콘을 그립니다.
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

// 사용자가 최소화된 창을 끄는 동안에 커서가 표시되도록 시스템에서
//  이 함수를 호출합니다.
HCURSOR CfileopentestDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

void CfileopentestDlg::Preset_Array()
{
	//190128 YWCho strFileType배열 초기값 저장 
	strFileType[eTYPE_FUJIFILM] = TYPE_FUJIFILM;
	strFileType[eTYPE_OLYMPUS] = TYPE_OLYMPUS;
	strFileType[eTYPE_EPSON] = TYPE_EPSON;
	strFileType[eTYPE_IMACON] = TYPE_IMACON;
	strFileType[eTYPE_CANON1] = TYPE_CANON1;
	strFileType[eTYPE_CANON2] = TYPE_CANON2;
	strFileType[eTYPE_CANON3] = TYPE_CANON3;
	strFileType[eTYPE_ADOBE] = TYPE_ADOBE;
	strFileType[eTYPE_MAMIYA1] = TYPE_MAMIYA1;
	strFileType[eTYPE_MAMIYA2] = TYPE_MAMIYA2;
	strFileType[eTYPE_LOGITECH] = TYPE_LOGITECH;
	strFileType[eTYPE_SAMSUNG] = TYPE_SAMSUNG;
	strFileType[eTYPE_PENTAX1] = TYPE_PENTAX1;
	strFileType[eTYPE_PENTAX2] = TYPE_PENTAX2;
	strFileType[eTYPE_PANASONIC] = TYPE_PANASONIC;
	strFileType[eTYPE_CASIO] = TYPE_CASIO;
	strFileType[eTYPE_KODAK1] = TYPE_KODAK1;
	strFileType[eTYPE_KODAK2] = TYPE_KODAK2;
	strFileType[eTYPE_KODAK3] = TYPE_KODAK3;
	strFileType[eTYPE_KODAK4] = TYPE_KODAK4;
	strFileType[eTYPE_KODAK5] = TYPE_KODAK5;
	strFileType[eTYPE_KODAK6] = TYPE_KODAK6;
	strFileType[eTYPE_SONY1] = TYPE_SONY1;
	strFileType[eTYPE_SONY2] = TYPE_SONY2;
	strFileType[eTYPE_SONY3] = TYPE_SONY3;
	strFileType[eTYPE_PHASEONE1] = TYPE_PHASEONE1;
	strFileType[eTYPE_PHASEONE2] = TYPE_PHASEONE2;
	strFileType[eTYPE_PHASEONE3] = TYPE_PHASEONE3;
	strFileType[eTYPE_MINOLTA] = TYPE_MINOLTA;
	strFileType[eTYPE_SIGMA] = TYPE_SIGMA;
	strFileType[eTYPE_RED] = TYPE_RED;
	strFileType[eTYPE_NICON1] = TYPE_NICON1;
	strFileType[eTYPE_NICON2] = TYPE_NICON2;
}

void CfileopentestDlg::CheckBoxDataSetting()
{
	CString strtmp;
	int nID = 0;
	strChoosenType = L"";
	for (int i = 0; i < 6; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			if (m_check[i][j].m_hWnd != NULL)	//존재하는 버튼일 경우!
			{
				bool bVal = m_check[i][j].GetCheck();	//버튼 체크 여부 판단 변수 
				if (bVal == true)
				{
					nID = m_check[i][j].GetDlgCtrlID();
					switch (nID)
					{	// ","개수로 찾아야 할 확장자명 개수를 알 수 있음.
					case IDC_CHECK1_1:
						strChoosenType += strFileType[eTYPE_SONY1] + L",@";
						strChoosenType += strFileType[eTYPE_SONY2] + L",@";
						strChoosenType += strFileType[eTYPE_SONY3] + L",@";
						break;
					case IDC_CHECK1_2:
						strChoosenType += strFileType[eTYPE_CANON1] + L",@";
						strChoosenType += strFileType[eTYPE_CANON2] + L",@";
						strChoosenType += strFileType[eTYPE_CANON3] + L",@";
						break;
					case IDC_CHECK1_3:
						strChoosenType += strFileType[eTYPE_NICON1] + L",@";
						strChoosenType += strFileType[eTYPE_NICON2] + L",@";
						break;
					case IDC_CHECK1_4:
						strChoosenType += strFileType[eTYPE_OLYMPUS] + L",@";
						break;

					case IDC_CHECK2_1:
						strChoosenType += strFileType[eTYPE_PANASONIC] + L",@";
						break;
					case IDC_CHECK2_2:
						strChoosenType += strFileType[eTYPE_SAMSUNG] + L",@";
						break;
					case IDC_CHECK2_3:
						strChoosenType += strFileType[eTYPE_PENTAX1] + L",@";
						strChoosenType += strFileType[eTYPE_PENTAX2] + L",@";
						break;
					case IDC_CHECK2_4:
						strChoosenType += strFileType[eTYPE_EPSON] + L",@";
						break;

					case IDC_CHECK3_1:
						strChoosenType += strFileType[eTYPE_MINOLTA] + L",@";
						break;
					case IDC_CHECK3_2:
						strChoosenType += strFileType[eTYPE_FUJIFILM] + L",@";
						break;
					case IDC_CHECK3_3:
						strChoosenType += strFileType[eTYPE_KODAK1] + L",@";
						strChoosenType += strFileType[eTYPE_KODAK2] + L",@";
						strChoosenType += strFileType[eTYPE_KODAK3] + L",@";
						strChoosenType += strFileType[eTYPE_KODAK4] + L",@";
						strChoosenType += strFileType[eTYPE_KODAK5] + L",@";
						strChoosenType += strFileType[eTYPE_KODAK6] + L",@";
						break;

					case IDC_CHECK4_1:
						strChoosenType += strFileType[eTYPE_ADOBE] + L",@";
						break;
					case IDC_CHECK4_2:
						strChoosenType += strFileType[eTYPE_LOGITECH] + L",@";
						break;
					case IDC_CHECK4_3:
						strChoosenType += strFileType[eTYPE_SIGMA] + L",@";
						break;
					case IDC_CHECK4_4:
						strChoosenType += strFileType[eTYPE_CASIO] + L",@";
						break;

					case IDC_CHECK5_1:
						strChoosenType += strFileType[eTYPE_MAMIYA1] + L",@";
						strChoosenType += strFileType[eTYPE_MAMIYA2] + L",@";
						break;
					case IDC_CHECK5_2:
						strChoosenType += strFileType[eTYPE_RED] + L",@";
						break;
					case IDC_CHECK5_3:
						strChoosenType += strFileType[eTYPE_IMACON] + L",@";
						break;

					case IDC_CHECK6_1:
						strChoosenType += strFileType[eTYPE_PHASEONE1] + L",@";
						strChoosenType += strFileType[eTYPE_PHASEONE2] + L",@";
						strChoosenType += strFileType[eTYPE_PHASEONE3] + L",@";
						break;

					default:
						break;
					}
				}
			}
		}
	}

	bool bVal = m_check_user.GetCheck();									//버튼 체크 여부 판단 변수 
	if (bVal == true)
	{
		GetDlgItemText(IDC_EDIT_USER, strtmp);
		strtmp.Remove(L' ');
		if (strtmp == L"")
			return;
		else
			strChoosenType += strtmp + L",@";
	}
	else
		return;


}

bool CfileopentestDlg::CheckTypeSelected()
{
	for (int i = 0; i < 6; i++) {
		for (int j = 0; j < 4; j++) {
			if (m_check[i][j].m_hWnd != NULL)								//존재하는 버튼일 경우!
			{
				bool bVal = m_check[i][j].GetCheck();						//버튼 체크 여부 판단 변수 
				if (bVal == true) {
					return true;
				}
			}
		}
	}

	AfxMessageBox(L"확장자가 선택되지 않았습니다.");
	return false;
}

bool CfileopentestDlg::CheckPathSelected()
{
	if (strFilePath_A == "" || strFilePath_B == "")							//경로 미 지정시 종료
	{
		AfxMessageBox(L"경로가 지정되지 않았습니다.");
		return false;
	}

	return true;
}

void CfileopentestDlg::OnBnClickedButton1()									//선택된 파일
{
	CFolderPickerDialog dlg(NULL, 0, NULL, 0);

	if (IDOK == dlg.DoModal()) {

		strFilePath_A = dlg.GetPathName();
		strFolderName_A = dlg.GetFileName();
		m_ctrl_Edit1.SetWindowTextW(strFilePath_A);	
	}

}

void CfileopentestDlg::OnBnClickedButton2()									//원본 파일
{
	CFolderPickerDialog dlg(NULL, 0, NULL, 0);

	if (IDOK == dlg.DoModal()) {

		strFilePath_B = dlg.GetPathName();
		m_ctrl_Edit2.SetWindowTextW(strFilePath_B);							//폴더 경로
	}
}

void CfileopentestDlg::OnBnClickedBtnWork()
{
	if (!CheckTypeSelected())												//확장자 미체크시 종료
		return;

	if (!CheckPathSelected())												//경로 미 지정시 종료 
		return;




	m_progress.SetPos(0);													//190318 PG Bar 초기화 

	CFileFind finder;
	CString default_type = L"";

	int nFileCnt(0);
	int nPrBarCnt(0);
	int nNoneCnt(0);
	bCancel = FALSE;

	BOOL bIsFile = finder.FindFile(strFilePath_A + L"\\*.*", 0);			//A폴더 경로에서 *.* 파일을 발견하면 TRUE 
	if (bIsFile == 0)														//A폴더에 내용 없으면 return 						
	{
		AfxMessageBox(L"선택된 폴더에 파일이 존재하지 않습니다.");
		return;
	}

	while (bIsFile != 0)
	{
		bIsFile = finder.FindNextFile();
		CString str = finder.GetFileName();

		int nFileLength = str.GetLength();									//파일명 길이 구하기
		int nFindPos = str.Find(L".");										//파일명에서 "."찾기
		if (nFileCnt >= 2) {
			if (nFindPos > 0)												// 두번째까지 이상한 값이 들어와서 이렇게 사용함. //만약 찾으면
			{
				strFileName[nFileCnt - 2] = str.Left(nFindPos);				//strFileName배열에 파일 이름 저장 
				CString ss = str.Right(nFileLength - nFindPos);
				if (ss.GetLength() > 2 && default_type == L"")
					default_type = ss;
			}
			else
			{
				nFileCnt--;													//파일 형식이 name.***가 아니기 때문에 nFileCnt에 제외시킴 
			}
		}
		nFileCnt++;	
	}
	nFileCnt -= 2;															//마지막에 2를 빼주기~


	CString strUserPath = (L"%s", strFilePath_A + L"\\" + strFolderName_A + L"_Original\\");	//190126
	

	m_progress.SetRange(0, nFileCnt);										//progressbar control

	CheckBoxDataSetting();
	int nTypeCnt = strChoosenType.Remove(L'@');
	
	//>>	190214 YWCho 확장자 선택 알고리즘 추가

	for (int i = 0; i < nFileCnt; i++)										//선택한 폴더의 사진 수만큼 반복
	{
		CString TEMPstrChoosenType = strChoosenType;						//확장명 복사 
		int TEMPPrBarCnt = nPrBarCnt;
		for (int j = 0; j < nTypeCnt; j++)
		{
			int n = TEMPstrChoosenType.Find(L',');							// ,(comma)의 위치값을 나타내는 변수.
			CString str = TEMPstrChoosenType.Left(n);						// ,전까지의 문자열을 str 변수에 저장.

			CString strPath = strFilePath_B + L"\\" + strFileName[i] + str;	//원본에서 파일 찾기위한 경로
			CString strNewPath = strUserPath + strFileName[i] + str;		//새로운 폴더에 붙여넣기 하기위한 경로

			if (finder.FindFile(strPath) == TRUE)							//파일을 발견하면 
			{
				DWORD dwRet = GetFileAttributes(strUserPath);				//파일 속성 얻기.		
				if (dwRet != FILE_ATTRIBUTE_DIRECTORY)						// 폴더가 존재하지 않는 경우.
					CreateDirectory(strUserPath, NULL);						// 폴더 생성 

				CopyFileEx(strPath, strNewPath, CopyProgressRoutine, NULL, &bCancel, COPY_FILE_FAIL_IF_EXISTS);
				//CopyFile(strPath, strNewPath,false);
				//MoveFileWithProgressW(strPath, strNewPath, NULL, NULL, 0);

				nPrBarCnt++;												//progress bar control
			}

			m_progress.SetPos(nPrBarCnt);									//progressbar control

																			//첫번째 확장자에 관한 비교가 끝나면 
			TEMPstrChoosenType.TrimLeft(str);								//첫번째 확장자 삭제하고,
			TEMPstrChoosenType.TrimLeft(',');								//컴마까지 삭제완료 한다.
		}

		if (TEMPPrBarCnt == nPrBarCnt)										//한 파일에 대한 여러 확장자를 다 검색해도 파일을 발견하지 못하면 
		{
			strFileNone[nNoneCnt] = strFileName[i];
			nNoneCnt++;
		}
	}
	//<<

	CString strTemp;
	strTemp.Format(L"%d개의 선택된 사진 중 %d개의 원본사진 복사 완료", nFileCnt, nPrBarCnt);
	AfxMessageBox(strTemp);
	if (nNoneCnt != 0) {
		strTemp.Format(L"원본 파일이 없는 파일도 복사하시겠습니까?(%d 개)", nNoneCnt);
		if (AfxMessageBox(strTemp, MB_YESNO) == IDYES)
		{
			int nConfirm = 0;
			for (int i = 0; i < nNoneCnt; i++)
			{
				CString strNonePath = strFilePath_A + L"\\" + strFileNone[i] + default_type;		//원본에서 파일 찾기위한 경로
				CString strNewNonePath = strUserPath + strFileNone[i] + default_type;			//새로운 폴더에 붙여넣기 하기위한 경로
				CopyFileEx(strNonePath, strNewNonePath, CopyProgressRoutine, NULL, &bCancel, 0);
				if (finder.FindFile(strNewNonePath) == TRUE)						//파일을 발견하면 
					nConfirm++;
				m_progress.SetPos(nPrBarCnt + nConfirm);								//progressbar control
			}

			strTemp.Format(L"%d개의 사진 복사 완료", nConfirm);
			AfxMessageBox(strTemp);
		}
	}

// 	for (int i = nPrBarCnt+1 ; i <= nFileCnt; i++)						//상태바 마저 체우기 190214
// 		m_progress.SetPos(i);


}

void CfileopentestDlg::OnBnClickedCheckAll()
{
	bool bVal = m_check_all.GetCheck();									//버튼 체크 여부 판단 변수 

	for (int i = 0; i < 6; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			if (m_check[i][j].m_hWnd != NULL)
			{
				m_check[i][j].SetCheck(bVal);							//체크 여부에 따라 체크
			}
		}
	}
}

DWORD CALLBACK CopyProgressRoutine(
	LARGE_INTEGER TotalFileSize,
	LARGE_INTEGER TotalBytesTransferred,
	LARGE_INTEGER StreamSize,
	LARGE_INTEGER StreamBytesTransferred,
	DWORD dwStreamNumber,
	DWORD dwCallbackReason,
	HANDLE hSourceFile,
	HANDLE hDestinationFile,
	LPVOID lpData)
{
	CString str;
	str.Format(L"%d   /   %d", TotalFileSize.LowPart, TotalBytesTransferred.LowPart);
	SetWindowTextW(pThis->m_txtctrl_pgbar, str);

	return PROGRESS_CONTINUE;
}

void CfileopentestDlg::OnBnClickedOk()
{
	CDialog::OnOK();
}


void CfileopentestDlg::OnBnClickedCancel()
{
	CDialogEx::OnCancel();
}


void CfileopentestDlg::OnBnClickedBtnCopycancel()
{

}
